# 148. |最小邮票数

## Question description


    有若干张邮票，要求从中选取最少的邮票张数凑成一个给定的总值。
    如，有1分，3分，3分，3分，4分五张邮票，要求凑成10分，则使用3张邮票：3分、3分、4分即可。


## Solution

Language: **C**

```C


//第二次做这个题目了，比第一次更难受
//这次用的是动态规划
#include<iostream>
#include<vector>
#define mmax 0x7fffffff
using namespace std;
int min(int a,int b){return a<b?a:b;}
int main()
{
    int m,n;
    while(cin>>m)
    {
/*****************读取数据区域****************************/
        cin>>n;
        vector<int> c(n);
        for(int i=0;i<n;i++)
            cin>>c[i]; 
/*****************读取数据区域****************************/
         
/*****************初始化区域****************************/
        vector<int> dp(m+1);
        for(int i=0;i<=m;i++)
            dp[i]=mmax;
        dp[0]=0;
/*****************初始化区域****************************/
         
/*****************循环体区域****************************/
/*方法大概类似于筛选法，
  题目中已经给出有序，不需要再次排序，
  对于每一个邮票来说，有且仅有一次使用机会
  所以遍历所有邮票，获取邮票的面值，
  对于每一个dp数组来说，dp[i]中的i代表总值，dp[i]中保存的数据为个数，
  遍历所有小于等于m的i，如果总值减去当前所选的邮票的面值，即i-c[i]合法并且可达
   那么i一定可达，
  并且dp[i]中的值应该是dp[i-c[i]]的值+1和原来的值中较小的一个。
  想想第二层循环，循环所有小于等于m的i时，为什么要倒序？*/
        for(int i=0;i<n;i++)  
        {                     
            for(int j=m;j>=0;j--)  
            {
                if(j-c[i]>=0&&dp[j-c[i]]!=mmax)
                {
                    dp[j]=min(dp[j],dp[j-c[i]]+1);
                }
            }
        }
/*****************循环体区域****************************/
         
/*****************输出数据区域****************************/
        if(dp[m]==mmax) cout<<0<<endl;
        else cout<<dp[m]<<endl;
/*****************输出数据区域****************************/
    }
}
```


